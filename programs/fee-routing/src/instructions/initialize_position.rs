use anchor_lang::prelude::*;
use anchor_spl::token::Token;
use crate::{
    constants::*,
    errors::FeeRoutingError,
    events::HonoraryPositionInitialized,
    meteora,
};

#[derive(Accounts)]
pub struct InitializePosition<'info> {
    /// Authority that can initialize the position (creator)
    #[account(mut)]
    pub authority: Signer<'info>,

    /// PDA that will own the honorary position (via NFT)
    /// CHECK: PDA that will be the owner field in create_position
    #[account(
        seeds = [VAULT_SEED, vault.key().as_ref(), INVESTOR_FEE_POS_OWNER_SEED],
        bump
    )]
    pub position_owner_pda: AccountInfo<'info>,

    /// CHECK: Vault account reference for PDA derivation
    pub vault: AccountInfo<'info>,

    // ===== Meteora CP-AMM Position Creation Accounts =====

    /// Position NFT mint (new keypair generated by client)
    /// Must be a signer
    pub position_nft_mint: Signer<'info>,

    /// Position NFT token account
    /// PDA: [b"position_nft_account", position_nft_mint]
    /// CHECK: Derived by Meteora program
    #[account(mut)]
    pub position_nft_account: AccountInfo<'info>,

    /// Position data account
    /// PDA: [b"position", position_nft_mint]
    /// CHECK: Derived by Meteora program
    #[account(mut)]
    pub position: AccountInfo<'info>,

    /// The CP-AMM pool
    /// CHECK: Validated by Meteora program
    #[account(mut)]
    pub pool: AccountInfo<'info>,

    /// Pool authority (constant address)
    /// CHECK: Must match POOL_AUTHORITY
    pub pool_authority: AccountInfo<'info>,

    /// Quote mint (token B typically)
    /// CHECK: Validated against pool configuration
    pub quote_mint: AccountInfo<'info>,

    /// Rent sysvar
    pub rent: Sysvar<'info, Rent>,

    /// Token program
    pub token_program: Program<'info, Token>,

    /// System program
    pub system_program: Program<'info, System>,

    /// Event authority for Meteora program
    /// Seeds: [b"__event_authority"]
    /// CHECK: Event authority PDA
    pub event_authority: AccountInfo<'info>,

    /// Meteora CP-AMM program
    /// CHECK: Must match CP_AMM_PROGRAM_ID
    pub cp_amm_program: AccountInfo<'info>,
}

pub fn initialize_position_handler(ctx: Context<InitializePosition>) -> Result<()> {
    // 1. Validate pool authority matches expected constant
    require!(
        ctx.accounts.pool_authority.key() == meteora::pool_authority(),
        FeeRoutingError::InvalidQuoteMint // TODO: Add InvalidPoolAuthority error
    );

    // 2. Validate quote mint is provided
    require!(
        ctx.accounts.quote_mint.key() != Pubkey::default(),
        FeeRoutingError::InvalidQuoteMint
    );

    // 3. Validate CP-AMM program ID
    require!(
        ctx.accounts.cp_amm_program.key() == meteora::cp_amm_program_id(),
        FeeRoutingError::InvalidQuoteMint // TODO: Add InvalidProgram error
    );

    // 4. Create position via CPI to Meteora CP-AMM
    // The position will be owned by our program PDA via NFT ownership
    let cpi_accounts = meteora::CreatePositionCPI {
        owner: ctx.accounts.position_owner_pda.to_account_info(),
        position_nft_mint: ctx.accounts.position_nft_mint.clone(),
        position_nft_account: ctx.accounts.position_nft_account.to_account_info(),
        pool: ctx.accounts.pool.to_account_info(),
        position: ctx.accounts.position.to_account_info(),
        pool_authority: ctx.accounts.pool_authority.to_account_info(),
        payer: ctx.accounts.authority.to_account_info(),
        rent: ctx.accounts.rent.to_account_info(),
        token_program: ctx.accounts.token_program.to_account_info(),
        system_program: ctx.accounts.system_program.to_account_info(),
        event_authority: ctx.accounts.event_authority.to_account_info(),
        program: ctx.accounts.cp_amm_program.to_account_info(),
    };

    // No signer seeds needed because position_owner_pda doesn't sign for Meteora
    // The NFT mint signs (passed from client), and owner is just a reference
    meteora::create_position_cpi(&cpi_accounts, &[])?;

    // 5. NOTE: Quote-only enforcement strategy
    // DAMM v2 / CP-AMM positions accrue fees in BOTH token A and token B.
    // To achieve "quote-only" distribution, we have several strategies:
    //
    // Strategy A (Recommended): Accept both tokens, swap baseâ†’quote in distribute_fees
    // Strategy B: Validate pool has minimal base token liquidity (prone to change)
    // Strategy C: Only distribute quote token, hold base token indefinitely
    //
    // For this implementation, we accept both tokens and will handle swapping
    // in the distribute_fees instruction.

    // 6. Emit event
    emit!(HonoraryPositionInitialized {
        position: ctx.accounts.position.key(),
        owner_pda: ctx.accounts.position_owner_pda.key(),
        quote_mint: ctx.accounts.quote_mint.key(),
        timestamp: Clock::get()?.unix_timestamp,
    });

    msg!("Honorary position created successfully");
    msg!("Position: {}", ctx.accounts.position.key());
    msg!("Position NFT Mint: {}", ctx.accounts.position_nft_mint.key());
    msg!("Owner PDA: {}", ctx.accounts.position_owner_pda.key());

    Ok(())
}
